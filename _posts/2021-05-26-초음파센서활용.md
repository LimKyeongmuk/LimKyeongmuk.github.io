---
title: "초음파 센서 활용"
excerpt: ""

categories:
  - Xycar
tags:
  - Xycar
  - Lidar
----
# 필터의 이해와 활용
### 필터의 개념
- 필터란?
  - 필터: 불순물을 걸러내고 깨끗한 물만 통과
  - 원래 목적하는 바를 남기고 나머지 불순물을 걸러내는 장치
  - 센서에서는 측정하는 값 중에서는 진짜 값과 잡음과 환경 또는 실수로 들어가는 것이 포함되어있기 때문에 걸러내기 위해서 사용함
  - 측정 데이터는 잡음이 포함되어있기 때문에 잡음을 걸러내고 진짜 데이터만 모아보기
  - 랜덤한 데이터들도 많이 모아보면 정규분포를 그림
  
- 재귀 필터(Recursize Filter)
  - 기존에 계산해놓은 결과값을 새로운 데이터 계산에 사용
  - 매번 전체 데이터에 대해서 다시 계산할 필요 없음
  - 누적된 과거 데이터와 현재의 측정치로 현상태를 정확하게 추정하고자 함
  
- 필터 공부하기
  - 출처/인용
    - 김성필 저자
      - "칼만 필터는 어렵지 않아 with MATLAB EXAMPLES"
  
    - Tomboy 블로그
      - https://m.blog.naver.com/skwd123/221827247721
  
### 다양한 필터 - 평균 필터
- 평균 필터
  - 평균: 데이터를 모두 합산한 다음에 개수로 나누면 평균값이 나옴
  - K개의 데이터에 대한 평균값: 모든값을 더한다음 K로 나눠줌

- 데이터가 하나 추가되면?
  - 모든 데이터를 다시 다 더한 후 K+1로 나눔
  - 앞서 계싼한 K의 평균을 이용하지 못함
  
- 평균의 재규식
  - K의 평균, K-1의 평균 구하기
  - 양변을 k-1로 나눠주고 분수를 나누기
  - k-1을 양변에 곱해주기
  - 그렇게 계산하면 K의 평균은 (K-1)/K * (K-1)의 총합 + 1/K * (K의 총합)
  - k-1개의 데이터에 대해서 평균값을 한번 계산해서 가지고 있으면 새로 추가된 k번째 데이터 때문에 이전 데이터를 다시 계산할 필요가 없음
  - 분모를 합쳐보면 K의 평균은 ((K-1) * (K-1)의 총합 + 1 * (K의 총합))/K

- 평균 필터
  - 평균의 재귀식을 간단하게 변형
  - a = (K-1)/K
  - 1/K = 1 - a
  - k의 평균 = a * (K-1)의 총합 + (1-a) * (K의 총합)

- 평균 필터(average filter)
  - 평균 계산에 사용
  - 센서 초기화에 사용
    - 처음 센서를 On 시키고 일정시간 동안 센서의 출력값을 모아서 평균 필터로 평균값을 구하고 이 값을 '0' 또는 '초기값'으로 세팅
  
- Average filter 예제
  - 전압 측정값에 대해서 average filter 적용
    - 10초 동안 0.2 간격으로 배터리의 전압을 측정
    - 배터리 전압 14.4V + 측정 잡음
    - 평균 필터를 사용하여 배터리의 전압을 추정하고자 함
  
- 요약
  - 평균 필터는 재귀적 필터
  - 직전 평균값과 데이터 개수만 알면 쉽고 빠르게 평균을 구할 수 있음
  - 데이터가 순차적으로 입력되는 경우 평균 필터의 효율성은 극대화됨
  - 데이터의 실시간 처리가 가능!
  
### 다양한 필터 - 이동평균 필터
- 평균 필터의 한계
  - 평균 필터는 시간에 따라 변하는 물리량에 적합하지 않음
  - 평균 데이터는 첫번째 데이터부터 계속 누적되기 때문에 너무 옛날 데이터를 계속 고려할 필요가 없음
  
- 옛날 데이터가 필요? 중요?한지 따져야함
  - 평균 수명 계산
  - 주식에서 주가 예측

- 이동 평균
  - 증권가의 주가 추이 계산의 사례
  - 100일 이동평균선, 20일 이동평균선, 5일 이동평균선
  
- 이동 평균 필터(Moving average filter)
  - 전체 측정 데이터를 사용하지 않음
  - 지정된 개수의 최근 측정ㄱ밧만 사용해서 평균을 구함
  - 평균은 k개 데이터의 평균이지만 이동 평균은 n개 데이터의 평균
  
- Moving average filter
  - k의 이동 평균값에서 k-1의 이동 평균값을 빼주면 (xk - xk-n)/n
  - k의 이동 평균 값은 k-1의 이동 평균값 - (xk - xk-n)/n
  - 새로운 이동평균을 계산하려면 이전의 이동평균값 xk-1과 옛날 데이터인 xk-n이 필요함
  - 다음번 이동평균을 구하려면 옜날데이터인 xk-n을 버리고 그 다음 데이터인 xk-n+1이 필요함
  - 재규식이기는 하나 옛날 데이터를 보관하고 있어야 하는 문제때문에 현실적으로는 재규적으로 구현하는 것보다 배치식으로 구현하는 것이 간단하고 이해하기 쉬움
  
- Moving average filter 예제
  - 초음파 센서 거리측정 측정값에 대해서 moving average filter 적용
    - 10초 동안 0.02초 간격으로 초음파센서 거리정보 측정
    - 측정거리 + 측정 잡음
    - N=1- 이동평균 필터를 사용하여 초음파센서의 거리 정보를 추정하고자 함
  
- 요약
  - 이동평균 필터는 측정 데이터의 잡음을 제거하는데 유용
    - 평균 계산에 사용되는 데이터의 개수가 많아지면 잡음 제거 성능은 좋아지지만 측정 신호의 변화가 제때에 반영되지 않고 시간 지연이 생김
    - 반대로 데이터의 개수가 적어지면 잡음 제거 성능은 나빠지지만 측정 신호의 변화는 잘 따라가게 됨
    - 데이터의 개수 N값을 적절히 잘 세팅해야 함
    
  - 알고리즘을 재귀적으로 구현해도 이점이 별로 없음

### 다양한 필터 - 저주파 통과 필터
- 측정 데이터에 주어지는 가중치
  - 이동평균 계산식을 풀어서 다시 써보기
  - 모든 데이터에 동일한 가중치 1/n을 부여하기
  - 하지만 적지 않은 경우에 최신 데이터가 옛날 데이터보다 더 중요함
  - 변화가 심한 데이터에 대해서는 잡음제거와 변화 민감성을 동시에 달성하기 어려움
  
- 저주파 통과필터
  - 이동평균 필터의 단점 개선
    - 오래된 데이터와 최신 데이터가 동일한 가중치를 갖는 문제
  
  - 저주파 통과 필터(1차 저주파 통과 필터)
    - 최근 측정값에는 높은 가중치를 주고, 오래된 값일수록 가중치를 낮음
  
  - 자율주행 자동차에서 1초 전 수집한 센서 데이터보다 방금 수집한 센서 데이터가 더 중요

- 저주파 통과 필터(Low-pass filter)
  - xk와 xk-1을 정리(추정값과 직전 추정값)
  - 여기서 상수항 a 관련 식의 크기를 살펴보면 a(1-a) < 1-a
  - a가 1보다 작기 때문에 a(1-a)이 더 작음(과거 데이터일수록 더 작은 계수가 곱해짐)
  
- 저주파 통과 필터
  - 오래된 측정값일수록 더 작은 가중치를 부여하는 필터
  - 가중치 차별화 특성으로 인해 잡음 제거와 변화 민감성이라는 상충되는 요구를 이동평균 필터보다 더 잘 충독시킴
  - 1차 저주파 통과필터는 지수 가중 이동평균 필터라고도 부름
  - (first order Low-pass filter = Exponentially weighted moving average filter)
  
- 1st order Low-pass filter 예제
  - 초음파센서 거리정보 측정값에 대해서 Low-pass filter 적용
    - 10초 동안 0.02초 간격으로 초음파센서 거리정보 측정
    - 측정거리 + 측정 잡음
    - 저주파 통과 필터(a=0.7) 사용하여 초음파센서의 거리정보를 추정하고자 함
  
- 요약
  - 상수 a 값에 따라 저주파 통과 필터의 추정값이 어떻게 바뀌는가?
  - a가 작은 값을 가질 경우
    - 1-a 값이 상대적으로 커지므로 추정값 계산에 측정값이 더 많이 반영됨
    - 잡음 제거보다는 측정값의 변화에 더 민감해짐
  
  - a가 큰 값을 가질 경우
    - 측정값보다는 직전 추정값의 비중이 더 커짐
    - 즉, 추정값이 직전 추정값과 별로 달라지지 않게 되는 셈
    - 잡음이 줄어들고 추정값 그래프의 변화가 무뎌짐
  
  - 1차 저주파 통과 필터의 수식은 매우 단순하고 구현하기 쉬움
  - 측정 신호의 변화 추이를 이동평균 필터보다 더 잘 감지해낼 수 있음
  - 최신 측정값일수록 가중치를 더 높게 주는 특성을 가짐
  
### 과제 - 가중이동평균 필터
- 측정 데이터에 주어지는 가중치
  - 이동평균 필터에는 모든 데이터에 동일한 가중치 1/n을 부여함
  - 저주파 통과 필터에는 a의 n승(제곱, 지수) 가중치를 부여함
  - 선형적으로 증가하는 가중치를 부여하는 필터(가중이동평균 필터)
  
- 가중 이동평균 필터
  - 사례
    - 샘플: A, B, C, D, E, F, G, H
    - 최신의 6개 샘플 데이터를 가지고 가중 이동평균값을 구하면 아래와 같은 식
  
  - 최신 데이터에 가중치를 더 주는 방식
    - 단, 지수방식이 아니라 산술방식으로
    - 옛날 데이터의 가중치가 지나치게 작아지는 것을 방지하기 위해서
  
- 과제
  - 파일명: WeightMovingAverageFilter.py
  - 앞서 사용한 데이터 파일 사용: SonarAlt.mat
  - 파이썬 파일과 결과 그림 파일을 제출: weight_moving_average_filter.png
  
# 초음파센서 ROS패키지 제작
### 초음파 센서를 위한 노드와 토픽
- 초음파 센서
  - 장애물까지의 거리를 알려주는 센서
  - 한쪽에서 초음파를 쏘면 다른 한쪽에서 반사된 초음파를 수신
  
- 초음파 센서
  - 모두 8개
    - 전방 3개, 후방 3개, 좌측 1개, 우측 1개
    
  - 아두이노를 거쳐서 프로세서와 연결
    - 초음파센서 노드의 역할을 둘 사이의 통신
  
  - 아두이노 1개에 초음파센서 4개씩 연결
  
- 초음파센서 관련 노드와 토픽
  - /xycar_ultrasonic노드에서 /xycar_ultrasonic 토픽을 이용
  
- 초음파센서 토닉
  - 타입: sensor_msgs/Int32MultiArray
  - 구성
  

### 초음파 센서 ROS 패키지 제작
- 초음파 센서와 아두이노를 사용하여 ROS 패키지를 직접 제작해보기
- 초음파센서 ROS 패키지
  - 기능
    - 초음파 센서를 제어하여 물체까지의 거리를 알아내고 그 정보를 ROS 토픽으로 만들어 노드들에게 보내줌
  
  - 초음파 센서
    - 물체로 초음파를 쏘고 반사된 초음파 신호를 감지
    - 처음 초음파를 쏜 시점과 반사파를 수신한 시점을 표시한 펄스 신호를 아두이노에게 보냄
    
  - 아두이노
    - 아두이노 펌웨어 제작 필요
    - 초음파센서가 보내준 펄스신호를 받아 분석함
    - 초음파를 쏜 시점과 반사파를 받은 시점의 시간차이를 이용해서 물체까지의 거리를 계산하고 이를 리눅스(ROS)에 알려줌
    
  - 리눅스 ROS
    - ROS 노드 SW 제작 필요
    - 아두이노가 보내준 물체까지의 거리정보를 사용하기 좋은 형태로 적절히 가공한 후에 ROS 토픽에 담아 그게 필요한 노드들에게 Publish 함
  
- 1단계: 우선 초음파센서 하드웨어를 이해하기
  - 초음파센서
    - 물체로 초음파를 쏘고 반사된 초음파 신호를 감지
    - 처음 초음파를 쏜 시점과 반사파를 수신한 시점을 표시한 펄스 신호를 아두이노에게 보냄
    
  - 초음파(Ultrasonic Wave)
    - 인간의 귀가 들을 수 있는 가청 주파수 대역보다 높은 진동수로 발생하는 파동
    - 가청 주파수는 사람마다 다르지만, 약 20Hz ~ 20kHz
    - 초음파 센서는 초음파를 이용하여 센서로부터 사물까지의 직선거리를 측정
  
  - 초음파센서 모듈
    - HC-SR04 사용
    - Working Voltage: DC 5V
    - Working Current: 15mA
    - Working Frequency: 40kHz
    - Max Range: 4m
    - Min Range: 2cm
    - Measuring Angle: 15 degree
    - Dimension: 45x20x15 mm
  
  - 초음파 센서의 동작 원리
    - 시그널
      - Vcc: 센서 부품에 전력 공급(DC 5V)
      - GND: 회로의 그라운드에 연결
      - Trig: 센서를 동작시키기 위한 트리거 시그널(입력)
      - Echo: 거리 측정 결과를 전달하기 위한 시그널(출력)
  
    - 동작 원리
      - 송신부에서 초음파를 발사함
      - 초음파가 물체에서 반사됨
      - 반사된 초음파가 수신부에서 감지됨
      - 송신과 수신 사이의 시간 간격을 기준으로 물체까지의 거리를 계산함
    
  - 초음파 센서의 동작 시나리오
    - 시작 > 초음파 발사와 수신 > 시간차 출력
    - 아두이노가 TRIG 핀에 10us 동안 High 신호를 보냄
    - 초음파센서가 40kHz 초음파펄스를 여덟 개 만들어 물체로 보냄
    - 물체에 반사된 초음파펄스가 되돌아가서 초음파센서에 수신됨
    - 센서는 송신과 수신의 시간차에 비례하는 길이의 펄스를 Echo 핀으로 출력함
  
  - 초음파센서를 이용한 거리 측정
    - 소리의 속도는 초속 340m(1초에 340미터 이동)
      - 1cm 이동하는데 약 29us 소요
    - 송신과 수신의 시간차 = 초음파의 왕복 이동시간이므로 물체까지의 거리는 ((송신과 수신의 시간차)/2)/29us
  
  - 초음파센서의 측정 오류
    - 쏜 신호가 되돌아와야 하는데 모두 흡수되거나 다른 곳으로 튕겨 나가면 오류
  
- 2단계: 아두이노의 역할을 이해하기
  - 아두이노
    - 초음파센서가 보내주는 펄스 신호를 받아 분석함
    - 초음파를 쏜 시점과 반사파를 받은 시점의 시간차이를 이용해서 물체까지의 거리를 계산하고 이를 리눅스(ROS)에 알려줌
  
  - 초음파센서와 아두이노의  연결
    - 각 센서의 Vcc, Trig, Echo, Gnd를 각 핀에 연결
    - Vcc: 5V
    - Trig: D2
    - Echo: D3
    - Gnd: GND
  
  - 아두이노 핀 배치도
    - 초음파센서가 아두이노의 어떤 핀에 연결되었는지 확인
    - 펌웨어에서 셋팅 작업에 필요
    
  - 아두이노 펌웨어 프로그래밍
    - 펌웨어를 제작해서 아두이노에 넣어야 함(소스 코드)
  
  - Arduino IDE 설치
  
  - 물체와의 거리 계산
    - 초음파 센서를 이용해서 물리와의 거리를 측정할 수 있음
    - 거리(미터) = (340미터 X 시간(초)) / 2 = 170 X 시간(초)
    - 거리(밀리미터) = 170 X 시간(마이크로 초) X 10의 3승 / 10의 6승
  
  - PC에서 아두이노 연결 확인
    - 아두이노를 USB 케이블로 연결한 후 아래 명령으로 인식됐는지 확인
    - $ lsusb 해서 HL-340 USB ~~가 나오는지 확인하기
  
  - USB 케이블 연결
    - 아두이노와 PC(또는 Nvidia보드)는 물리적으로 USB 케이블로 연결
    - 하지만 내부적으로는 Serial 통신이 이루어짐
    - SW 입장에서는 Serial over USB(USB 케이블 위에서 시리얼 통신 진행)
  
  - 리눅스에서 아두이노 연결 확인
    - Tools 메뉴에서 Board/Processor Port 체크
    - Board
      - Arduino Nano
  
    - Processor
      - ATmega328P
  
    - Port
      - /dev/ttyUSB0(여기는 달라질 수 있음)
  
  - 컴파일 & 업로드(아두이노에 펌웨어 적어넣기)
    - 컴파일: 소스코드 에러 체크하고 컴파일함
    - 업로드: 만들어진 펌웨어를 아두이노 안에 적어 넣음
  
  - 결과 확인
    - 시리얼 모니터를 이용해서 아두이노의 출력값 확인
    - Tools > Serial Monitor(Ctrl+Shift+M)
  
- 3단계: 리눅스 프로그래밍
  - 리눅스 ROS
    - 아두이노가 보내주는 물체까지의 거리정보를 사용하기 좋은 형태로 적절히 가공한 후에 ROS 토픽에 담아 그게 필요한 노드들에게 Publish 함
    - 원래 ROS에서는 m(미터) 단위를 사용해야 함
    
  - ROS에서의 시리얼 통신
    - 리눅스에서 시리얼 디바이스에 접근
    - 파이썬에서 Serial 모듈을 import 해서 코딩
    - ultrasonic은 import Serial을 통해서 /dev/ttyUSB0과 통신
  
  - 실행 결과
    - 초음파센서 데이터를 담은 토픽의 내용이 화면에 출력
    - Subscriber의 출력 결과
    
  - 초음파센서 데이터 송수신 결과 확인
    - $rqt_graph
    - $rostopic ech ultrasonic
  
# 초음파센서 ROS 패키지 확장
### 기존 초음파센서 ROS 패키지 분석
- 자이카의 초음파 센서
  - 모두 8개(전방 3개, 후방 3개, 좌측 1개, 우측 1개)
  - 아두이노를 거쳐서 프로세서와 연결(역할은 초음파센서와 프로세서 사이의 통신)
  - 아두이노 1개에 초음파센서 4개씩 연결(USB를 통해서)
  
- 자이카의 초음파센서 ROS Package
  - xycar_ultrasonic 패키지
  
- 자이카 초음파센서 관련 노드와 토픽
  - /xycar_ultrasonic 노드에 /xycar_ultrasonic 토픽
  
- 자이카 초음파센서 토픽의 메시지 타입
  - /xycar_ultrasonic 토픽의 메시지 타입
  - 타입 = sensor_msgs/Int32MultiArray
  - 구성
    - layout: 배열 구조체 정보
      - dim
      - data_offset
  
    - data: int32[] 구조로 초음파센서 거리정보를 담고 있는 배열(int32 x 8개)
  
- 내가 만든 초음파센서 ROS 패키지
  - 초음파센서 1개 + 아두이노 1개 + USB 케이블 (+PC와 연결)
  - ultrasonic 패키지
  - /ultrasonic 노드에 /ultrasonic 토픽
  - 타입: sensor_msgs/int32
  - 구성: int32 data

### 과제 설명: 초음파 센서 4개를 지원하는 ROS 패키지 제작
- 과제 개요: 초음파센서 4개 지원
  - 초음파센서 4개를 지원하는 ROS 패키지 제작하기
  - 4선 X 4개 점퍼 연결
  - 4개이므로 펌웨어 프로그램이 수정해야함
  - Linux & ROS에서도 토픽을 발행할 때 4개를 발행해야함
  
- 노드와 토픽, 메시지 타입
  - 노드
    - ultrasonic4
  
  - 토픽
    - /ultra4
    
  - 메시지 타입
    - Int32MultiArray(4개의 Int32 숫자 저장)
  
- 초음파 센서 4개를 아두이노 보드와 연결
  - 각 센서 Vcc, Trig, Echo, Gnd를 각 핀에 연결
  
- 초음파센서 4개를 관리하도록 펌웨어 코드 수정
  - ultrasonic_4_fw.ino 파일 작성하기
  - 초음파센서 개수 수정
    - 1개 > 4개
  
  - 4개 초음파 센서의 거리정보를 아래와 같은 모양의 문자열로 표시하도록 수정
    - 300mm 121mm 186mm 67mm
  
- 아두이노의 출력 데이터 모습
  - 아두이노 보드 1개에서 4개의 초음파센서가 센싱한 데이터를 출력함
  
- 디렉토리 구조와 파일 이름
  - ultrasonic